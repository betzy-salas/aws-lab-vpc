---
AWSTemplateFormatVersion: '2010-09-09'
Description: This stack deploys the core network infrastructure and IAM resources
             to be used for a service hosted in Amazon ECS using AWS EC2.

Mappings:
  # Hard values for the subnet masks. These masks define
  # the range of internal IP addresses that can be assigned.
  # The VPC can have all IP's from 10.0.0.0 to 10.0.255.255
  # There are four subnets which cover the ranges:
  #
  # 10.0.0.0 - 10.0.0.255
  # 10.0.1.0 - 10.0.1.255
  # 10.0.2.0 - 10.0.2.255
  # 10.0.3.0 - 10.0.3.255
  #
  # If you need more IP addresses (perhaps you have so many
  # instances that you run out) then you can customize these
  # ranges to add more
  SubnetConfig:
    VPC:
      CIDR: '10.0.0.0/16'
    PublicOne:
      CIDR: '10.0.0.0/24'
    PublicTwo:
      CIDR: '10.0.1.0/24'
    PrivateOne:
      CIDR: '10.0.2.0/24'
    PrivateTwo:
      CIDR: '10.0.3.0/24'
Resources:
  # VPC in which containers will be networked.
  # It has two public subnets, and two private subnets.
  # We distribute the subnets across the first two available subnets
  # for the region, for high availability.
  MyVPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true
      CidrBlock: !FindInMap ['SubnetConfig', 'VPC', 'CIDR']

  # Two public subnets, where a public load balancer will later be created.
  PublicSubnetPetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 0
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'MyVPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicOne', 'CIDR']
      MapPublicIpOnLaunch: true
  PublicSubnetPetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 1
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'MyVPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicTwo', 'CIDR']
      MapPublicIpOnLaunch: true

  # Two private subnets where containers will only have private
  # IP addresses, and will only be reachable by other members of the
  # VPC
  PrivateSubnetPetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 0
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'MyVPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PrivateOne', 'CIDR']
  PrivateSubnetPetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 1
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: !Ref 'MyVPC'
      CidrBlock: !FindInMap ['SubnetConfig', 'PrivateTwo', 'CIDR']

  # Setup networking resources for the public subnets.
  InternetGatewayPet:
    Type: AWS::EC2::InternetGateway
  GatewayAttachementPet:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'MyVPC'
      InternetGatewayId: !Ref 'InternetGatewayPet'
  PublicRoutePetTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'MyVPC'
  PublicRoutePet:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachementPet
    Properties:
      RouteTableId: !Ref 'PublicRoutePetTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGatewayPet'
  PublicSubnetPetOneRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetPetOne
      RouteTableId: !Ref PublicRoutePetTable
  PublicSubnetPetTwoRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetPetTwo
      RouteTableId: !Ref PublicRoutePetTable

  # Setup networking resources for the private subnets. Containers
  # in these subnets have only private IP addresses, and must use a NAT
  # gateway to talk to the internet. We launch two NAT gateways, one for
  # each private subnet.
  NatGatewayPetOneAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachementPet
    Properties:
        Domain: vpc
  NatGatewayPetTwoAttachment:
    Type: AWS::EC2::EIP
    DependsOn: GatewayAttachementPet
    Properties:
        Domain: vpc
  NatGatewayPetOne:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayPetOneAttachment.AllocationId
      SubnetId: !Ref PublicSubnetPetOne
  NatGatewayPetTwo:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGatewayPetTwoAttachment.AllocationId
      SubnetId: !Ref PublicSubnetPetTwo
  PrivateRouteTablePetOne:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'MyVPC'
  PrivateRoutePetOne:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTablePetOne
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayPetOne
  PrivateRouteTablePetOneAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTablePetOne
      SubnetId: !Ref PrivateSubnetPetOne
  PrivateRouteTablePetTwo:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'MyVPC'
  PrivateRoutePetTwo:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTablePetTwo
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGatewayPetTwo
  PrivateRouteTablePetTwoAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTablePetTwo
      SubnetId: !Ref PrivateSubnetPetTwo

  # VPC Endpoint for DynamoDB
  # If a container needs to access DynamoDB (coming in module 3) this
  # allows a container in the private subnet to talk to DynamoDB directly
  # without needing to go via the NAT gateway.
  DynamoDBEndpointPet:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: "*"
            Principal: "*"
            Resource: "*"
      RouteTableIds:
        - !Ref 'PrivateRouteTablePetOne'
        - !Ref 'PrivateRouteTablePetTwo'
      ServiceName: !Join [ "", [ "com.amazonaws.", { "Ref": "AWS::Region" }, ".dynamodb" ] ]
      VpcId: !Ref 'MyVPC'

  # The security group for our service containers to be hosted in EC2.
  # Even though traffic from users will pass through a Network Load Balancer,
  # that traffic is purely TCP passthrough, without security group inspection.
  # Therefore, we will allow for traffic from the Internet to be accepted by our
  # containers.  But, because the containers will only have Private IP addresses,
  # the only traffic that will reach the containers is traffic that is routed
  # to them by the public load balancer on the specific ports that we configure.
  ECSContainerSecurityGroupPet:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Access to the EC2 containers from the Internet
      VpcId: !Ref 'MyVPC'
      SecurityGroupIngress:
          # Allow access to NLB from anywhere on the internet
          - CidrIp: !FindInMap ['SubnetConfig', 'VPC', 'CIDR']
            IpProtocol: -1

  # This is an IAM role which authorizes ECS to manage resources on your
  # account on your behalf, such as updating your load balancer with the
  # details of where your containers are, so that traffic can reach your
  # containers.
  EcsServiceRolePet:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ecs.amazonaws.com
            - ecs-tasks.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: /
      Policies:
      - PolicyName: ecs-service
        PolicyDocument:
          Statement:
          - Effect: Allow
            Action:
              # Rules which allow ECS to attach network interfaces to instances
              # on your behalf in order for awsvpc networking mode to work right
              - 'ec2:AttachNetworkInterface'
              - 'ec2:CreateNetworkInterface'
              - 'ec2:CreateNetworkInterfacePermission'
              - 'ec2:DeleteNetworkInterface'
              - 'ec2:DeleteNetworkInterfacePermission'
              - 'ec2:Describe*'
              - 'ec2:DetachNetworkInterface'

              # Rules which allow ECS to update load balancers on your behalf
              # with the information sabout how to send traffic to your containers
              - 'elasticloadbalancing:DeregisterInstancesFromLoadBalancer'
              - 'elasticloadbalancing:DeregisterTargets'
              - 'elasticloadbalancing:Describe*'
              - 'elasticloadbalancing:RegisterInstancesWithLoadBalancer'
              - 'elasticloadbalancing:RegisterTargets'

              # Rules which allow ECS to run tasks that have IAM roles assigned to them.
              - 'iam:PassRole'

              # Rules that let ECS interact with container images.
              - 'ecr:GetAuthorizationToken'
              - 'ecr:BatchCheckLayerAvailability'
              - 'ecr:GetDownloadUrlForLayer'
              - 'ecr:BatchGetImage'

              # Rules that let ECS create and push logs to CloudWatch.
              - 'logs:DescribeLogStreams'
              - 'logs:CreateLogStream'
              - 'logs:CreateLogGroup'
              - 'logs:PutLogEvents'

            Resource: '*'

  # This is a role which is used by the ECS tasks. Tasks in Amazon ECS define
  # the containers that should be deployed togehter and the resources they
  # require from a compute/memory perspective. So, the policies below will define
  # the IAM permissions that our Mythical Mysfits docker containers will have.
  # If you attempted to write any code for the Mythical Mysfits service that
  # interacted with different AWS service APIs, these roles would need to include
  # those as allowed actions.
  ECSTaskRolePet:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: [ecs-tasks.amazonaws.com]
          Action: ['sts:AssumeRole']
      Path: /
      Policies:
        - PolicyName: AmazonECSTaskRolePolicy
          PolicyDocument:
            Statement:
            - Effect: Allow
              Action:
                # Allow the ECS Tasks to download images from ECR
                - 'ecr:GetAuthorizationToken'
                - 'ecr:BatchCheckLayerAvailability'
                - 'ecr:GetDownloadUrlForLayer'
                - 'ecr:BatchGetImage'

                # Allow the ECS tasks to upload logs to CloudWatch
                - 'logs:CreateLogStream'
                - 'logs:CreateLogGroup'
                - 'logs:PutLogEvents'
              Resource: '*'

            - Effect: Allow
              Action:
                # Allows the ECS tasks to interact with only the MyPets
                # in DynamoDB
                - 'dynamodb:Scan'
                - 'dynamodb:Query'
                - 'dynamodb:UpdateItem'
                - 'dynamodb:GetItem'
              Resource: 'arn:aws:dynamodb:*:*:table/MyPets*'
              
  # Rather than directly expose our service to the Internet,  
  # we will provision a Network Load Balancer (NLB)
  # to sit in front of our service tier
  MyPetsLoadBalancerPet:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: "myPets-nlb"
      Scheme: "internet-facing"
      Subnets :
        - !Ref PublicSubnetPetOne
        - !Ref PublicSubnetPetTwo
      Type: "network"
  
  # A target group allows AWS resources to register themselves as targets for requests 
  # that the load balancer receives to forward. Our service containers will automatically 
  # register to this target so that they can receive traffic from the NLB when they are 
  #provisioned
  MyPetsTargetGroupPet:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: "MyPets-TargetGroup"
      Port: 8080
      Protocol: "TCP"
      TargetType: "ip"
      HealthCheckIntervalSeconds: 10
      HealthCheckProtocol: "HTTP"
      HealthyThresholdCount: 3
      UnhealthyThresholdCount: 3
      HealthCheckPath: "/"
      VpcId: !Ref 'MyVPC'
    DependsOn: MyVPC
  
  # This informs that load balancer that for requests received on a specific port, 
  # they should be forwarded to targets that have registered to the above target group
  MyPetsLoadBalancerListenerPet:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Ref MyPetsLoadBalancerPet
      Port: 80
      Protocol: "TCP"
      DefaultActions:
        - Type : "forward"
          TargetGroupArn: !Ref MyPetsTargetGroupPet
          
  # We're ready to create a container image repository in Amazon Elastic Container 
  # Registry (Amazon ECR) and push our image into it
  ECRRepositoryPets:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: "mypets/service"
      RepositoryPolicyText:
        Version: "2012-10-17"
        Statement:
          -
            Sid: AllowPushPull
            Effect: Allow
            Principal: "*"
            Action:
              - "ecr:GetDownloadUrlForLayer"
              - "ecr:BatchGetImage"
              - "ecr:BatchCheckLayerAvailability"
              - "ecr:PutImage"
              - "ecr:InitiateLayerUpload"
              - "ecr:UploadLayerPart"
              - "ecr:CompleteLayerUpload"

# These are the values output by the CloudFormation template. Be careful
# about changing any of them, because of them are exported with specific
# names so that the other task related CF templates can use them.
Outputs:
  CurrentRegion:
    Description: REPLACE_ME_REGION
    Value: !Ref AWS::Region
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'CurrentRegion' ] ]
  CurrentAccount:
    Description: REPLACE_ME_ACCOUNT_ID
    Value: !Ref AWS::AccountId
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'CurrentAccount' ] ]
  EcsServiceRolePet:
    Description: REPLACE_ME_ECS_SERVICE_ROLE_ARN
    Value: !GetAtt 'EcsServiceRolePet.Arn'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'EcsServiceRolePet' ] ]
  ECSTaskRolePet:
    Description: REPLACE_ME_ECS_TASK_ROLE_ARN
    Value: !GetAtt 'ECSTaskRolePet.Arn'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ECSTaskRolePet' ] ]
  VPCId:
    Description: REPLACE_ME_VPC_ID
    Value: !Ref 'MyVPC'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'VPCId' ] ]
  PublicSubnetPetOne:
    Description: REPLACE_ME_PUBLIC_SUBNET_ONE
    Value: !Ref 'PublicSubnetPetOne'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PublicSubnetPetOne' ] ]
  PublicSubnetPetTwo:
    Description: REPLACE_ME_PUBLIC_SUBNET_TWO
    Value: !Ref 'PublicSubnetPetTwo'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PublicSubnetPetTwo' ] ]
  PrivateSubnetPetOne:
    Description: REPLACE_ME_PRIVATE_SUBNET_ONE
    Value: !Ref 'PrivateSubnetPetOne'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PrivateSubnetPetOne' ] ]
  PrivateSubnetPetTwo:
    Description: REPLACE_ME_PRIVATE_SUBNET_TWO
    Value: !Ref 'PrivateSubnetPetTwo'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'PrivateSubnetPetTwo' ] ]
  ECSContainerSecurityGroupPet:
    Description: REPLACE_ME_SECURITY_GROUP_ID
    Value: !Ref 'ECSContainerSecurityGroupPet'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ECSContainerSecurityGroupPet' ] ]
  MyPetsLoadBalancerPet:
    Description: REPLACE_ME_LOAD_BALANCER
    Value: !Ref 'MyPetsLoadBalancerPet'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'MyPetsLoadBalancerPet' ] ]
  MyPetsTargetGroupPet:
    Description: REPLACE_ME_TARGET_GROUP
    Value: !GetAtt 'MyPetsTargetGroupPet.TargetGroupFullName'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'MyPetsTargetGroupPet' ] ]
  MyPetsLoadBalancerListenerPet:
    Description: REPLACE_ME_LOAD_BALANCER_LISTENER
    Value: !Ref 'MyPetsLoadBalancerListenerPet'
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'MyPetsLoadBalancerListenerPet' ] ]
  ECRRepositoryPets:
    Description: REPLACE_ME_ECR_REPOSITORY
    Value: !GetAtt ECRRepositoryPets.Arn
    Export:
      Name: !Join [ ':', [ !Ref 'AWS::StackName', 'ECRRepositoryPets' ] ]
